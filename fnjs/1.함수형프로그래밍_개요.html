<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 순수함수: 부수효과를 일으키지 않고 외부상태를 변화시키니 않고 인자로 받은 값을 계산하여 리턴하는 역할만 한다.
      function add(a, b) {
        return a + b;
      }

      // 특징 1. 동일한 인자를 받으면 동일한 결과를 리턴한다.
      console.log(add(4, 6));

      // 순수함수가 아닌 조건 1. 참조하는 값에 따라 리턴값이 달라진다.
      let c = 10;
      function add2(a, b) {
        return a + b + c;
      }
      // 참조하는 변수 c가 상수라면 순수함수지만 변하는 값이라면 순수함수가 아니다.
      console.log(add2(2, 3));
      c = 16;
      console.log(add2(2, 3)); // c의 값에 따라 리턴값이 달라지므로 순수함수가 아니다.

      // 순수함수가 아닌 조건 2. 부수효과를 일으키는 함수
      // - 외부의 상태를 변화시키는 함수
      // 들어온 인자값을 직접 변경시키는 함수

      function add3(a, b) {
        c = b; // 외부값 c의 상태를 변화시키므로 순수함수가 아니다.
        return a + b;
      }

      let obj1 = { value: 1 };
      function add4(obj, b) {
        obj.value += b; // 인자로 받은 값을 직접 변경하므로 순수함수가 아니다.
      }
      console.log(obj1);
      add4(obj1, 4);
      console.log(obj1);

      // 다시 순수함수
      function add5(obj, b) {
        return { value: obj.value + b }; // 인자로 받은 obj의 값을 참조만 할뿐 값을 직접 변경하지 않는다.
      }

      console.log(obj1);
      const obj2 = add5(obj1, 5);
      console.log(obj1);
      console.log(obj2);

      // 함수형 프로그래밍은 외부의 값, 인자로 받은값을 직접적으로 변화시키지 않는다.

      // 특징 2. 평가 시점이 중요하지 않다.
      // 같은 인자를 넣으면 어느 시점에 실행해도 리턴값이 동일하다.(외부의 변화에 영행받지 않기 때문)

      // 일급 함수, 함수를 값으로 다룰 수 있는 개념
      // 자바스크립트의 함수는 일급함수다. 즉, 함수를 변수에 담을 수 있고 인자로 넣을 수 있다.

      const f1 = function (a) {
        return a * a;
      };

      console.log(f1);

      function f3(f) {
        return f();
      }

      console.log(
        f3(function () {
          return 10;
        })
      );

      // 순수함수라는 특징과 일급함수의 개념을 이용해 조합성을 높여나가는 것이 함수형 프로그래밍
      // 언제 평가해도 상관없는 순수함수들을 많이 만들고
      // 그 순수함수들을 값으로 들고다니면서 가장 절적한 필요시점에 평가하는 로직을 만들어나가는 것

      // add_maker
      function add_maker(a) {
        return function (b) {
          // 클로저
          return a + b;
        };
      }

      const add10 = add_maker(10);
      console.log(add10(20));

      function f4(f1, f2, f3) {
        return f3(f1 + f2);
      }
      console.log(
        f4(
          () => 2,
          () => 4,
          (a) => a * a
        )
      );

      // 객체지향과 함수형의 차이
      // duck.speak()

      // 데이터(객체) 기준
      // speak(duck)

      // 객체지향: 데이터를 먼저 디자인하고 데이터에 맞는 메서드를 만든다.
      // 함수형: 함수를 만들고 그 함수에 맞게 데이터셋을 구성한다.
    </script>
  </body>
</html>
